package scriptie.datastructures;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.DirectedGraph;
import org.jgrapht.Graph;
import org.jgrapht.GraphPath;
import org.jgrapht.Graphs;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.GraphPathImpl;
import org.jgrapht.util.FibonacciHeap;
import org.jgrapht.util.FibonacciHeapNode;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

/**
 * ShortestPath tree generated from a JGrapht graph. Note that the direction of
 * the tree is different from Eppstein.
 * 
 * @author tim
 * 
 * @param <V>
 *            Type of the original Vertices.
 * @param <E>
 *            Type of the original Edges.
 */
public class ShortestPathTree<V, E extends DefaultWeightedEdge> extends
		DefaultDirectedGraph<ShortestPathTreeNode<V, E>, DefaultEdge> implements
		ITree<ShortestPathTreeNode<V, E>> {

	private static final long serialVersionUID = 1L;
	private DirectedGraph<V, E> graph;
	private FibonacciHeap<QueueEntry<V, E>> heap =
			new FibonacciHeap<QueueEntry<V, E>>();
	private Map<V, FibonacciHeapNode<QueueEntry<V, E>>> heapNodes =
			new HashMap<V, FibonacciHeapNode<QueueEntry<V, E>>>();
	public Map<V, ShortestPathTreeNode<V, E>> treeNodes =
			new HashMap<V, ShortestPathTreeNode<V, E>>();

	private ShortestPathTreeNode<V, E> RootNode;

	public ShortestPathTree(DirectedGraph<V, E> graph, V endVertex) {
		super(DefaultEdge.class);
		this.graph = graph;

		initializeHeap(endVertex);

		while (!heap.isEmpty()) {
			FibonacciHeapNode<QueueEntry<V, E>> newNode = heap.removeMin();
			insertIntoTree(newNode);
			updatePaths(newNode);
		}

		RootNode = treeNodes.get(endVertex);

		// List<ShortestPathTreeNode<V, E>> verticesInTree =
		// this.getTreeNodes(RootNode);
		// // TODO: make sure no extra nodes besides the nodes in the tree are
		// in
		// // the graph
		// for (ShortestPathTreeNode<V, E> node : verticesInTree) {
		// if (!verticesInTree.contains(node)) {
		// this.removeVertex(node);
		// }
		// }
	}

	/**
	 * Gets the the children of the node by taking all outgoing edges and
	 * finding the corresponding nodes at the other side.
	 * 
	 * @param node
	 * @return
	 */
	@Override
	public Iterable<ShortestPathTreeNode<V, E>> getChildren(
			ShortestPathTreeNode<V, E> node) {
		return Graphs.successorListOf(this, node);
	}

	/**
	 * Gets the nodes in the ShortestPathTree. This is done because vertexSet()
	 * can contain more than the nodes in the tree.
	 * 
	 * @return the nodes in the tree
	 */
	public Iterable<ShortestPathTreeNode<V, E>> getTreeNodes() {
		return getTreeNodesInternal(RootNode);
	}

	private List<ShortestPathTreeNode<V, E>> getTreeNodesInternal(
			ShortestPathTreeNode<V, E> currentNode) {
		LinkedList<ShortestPathTreeNode<V, E>> nodes =
				new LinkedList<ShortestPathTreeNode<V, E>>();
		nodes.add(currentNode);
		for (ShortestPathTreeNode<V, E> node : this.getChildren(currentNode)) {
			nodes.addAll(getTreeNodesInternal(node));
		}
		return nodes;
	}

	/**
	 * Gets the parents of the ShortestPathTreeNode
	 * 
	 * @param node
	 *            Node of which the parent is needed
	 * @return The parent of node. Or null if no parent is found.
	 */
	public ShortestPathTreeNode<V, E> getParent(ShortestPathTreeNode<V, E> node) {
		return Iterables.getOnlyElement(Graphs.predecessorListOf(this, node),
				null);
	}

	// public GraphPath<V, E> getShortestPath(V from) {
	// LinkedList<E> edges = new LinkedList<E>();
	//
	// ShortestPathTreeNode<V, E> toTreeNode = RootNode;
	// ShortestPathTreeNode<V, E> currentTreeNode = treeNodes.get(from);
	//
	// // add parent to edges as long as the root isn't reached
	// while (!toTreeNode.equals(currentTreeNode)) {
	// edges.add(currentTreeNode.correspondingGraphEdgeToParent);
	// currentTreeNode = this.getParent(currentTreeNode);
	// }
	//
	// return new GraphPathImpl<V, E>(graph, from,
	// RootNode.correspondingVertex, edges, 0);
	// }

	/**
	 * Gets the shortest path generated by the ShortestPathTree
	 * 
	 * @param from
	 */
	public GraphPath<V, E> getShortestPath(V from) {
		return getShortestPath(from, Collections.<E> emptyList());
	}

	/**
	 * Gets the shortest path including given sidetracks.
	 * 
	 * @param from
	 * @param sideTracks
	 * @return
	 */
	public GraphPath<V, E> getShortestPath(V from, Iterable<E> sideTracks) {
		final List<E> sideTracksList = Lists.newArrayList(sideTracks);
		LinkedList<E> edges = new LinkedList<E>();
		Double costs = 0.0;

		ShortestPathTreeNode<V, E> toTreeNode = RootNode;
		ShortestPathTreeNode<V, E> currentTreeNode = treeNodes.get(from);

		// add parent to edges as long as the root isn't reached
		while (!toTreeNode.equals(currentTreeNode) || !sideTracksList.isEmpty()) {
			E sideTrack =
					Iterables
							.find(graph
									.outgoingEdgesOf(currentTreeNode.correspondingVertex),
									new Predicate<E>() {
										@Override
										public boolean apply(E input) {
											return (Iterables.contains(
													sideTracksList, input));
										}
									}, null);

			if (sideTrack != null) {
				// sidetrack value has been found
				sideTracksList.remove(sideTrack);
			} else {
				sideTrack = currentTreeNode.correspondingGraphEdgeToParent;
			}

			// if sideTrack still isn't null (can happen with unused nodes)
			if (sideTrack != null) {
				edges.add(sideTrack);
				costs += graph.getEdgeWeight(sideTrack);

				currentTreeNode =
						treeNodes
								.get(Graphs.getOppositeVertex(graph, sideTrack,
										currentTreeNode.correspondingVertex));
			} else {
				break;
			}
		}

		return new GraphPathImpl<V, E>(graph, from,
				RootNode.correspondingVertex, edges, costs);
	}

	private void insertIntoTree(FibonacciHeapNode<QueueEntry<V, E>> node) {
		V correspondingVertex = node.getData().correspondingVertex;
		E correspondingEdge = node.getData().spanningTreeEdge;
		ShortestPathTreeNode<V, E> insertedNode =
				new ShortestPathTreeNode<V, E>(correspondingVertex,
						correspondingEdge, node.getKey());
		this.addVertex(insertedNode);
		treeNodes.put(correspondingVertex, insertedNode);
		if (correspondingEdge != null) {
			V oppositeVertex =
					Graphs.getOppositeVertex(graph, correspondingEdge,
							correspondingVertex);
			this.addEdge(treeNodes.get(oppositeVertex), insertedNode);
		}
	}

	private void initializeHeap(V endVertex) {
		for (V vertex : graph.vertexSet()) {
			FibonacciHeapNode<QueueEntry<V, E>> newNode;
			QueueEntry<V, E> entry = new QueueEntry<V, E>(vertex, null);
			if (vertex != endVertex) {
				newNode = new FibonacciHeapNode<QueueEntry<V, E>>(entry);
				heap.insert(newNode, Double.POSITIVE_INFINITY);
			} else {
				newNode = new FibonacciHeapNode<QueueEntry<V, E>>(entry);
				heap.insert(newNode, 0);
			}
			heapNodes.put(vertex, newNode);
		}
	}

	private void updatePaths(FibonacciHeapNode<QueueEntry<V, E>> currentHeapNode) {
		V currentVertex = currentHeapNode.getData().correspondingVertex;
		for (E edge : graph.incomingEdgesOf(currentVertex)) {
			V oppositeVertex =
					Graphs.getOppositeVertex(graph, edge, currentVertex);

			FibonacciHeapNode<QueueEntry<V, E>> oppositeHeapNode =
					heapNodes.get(oppositeVertex);
			double newWeight =
					graph.getEdgeWeight(edge) + currentHeapNode.getKey();
			if (oppositeHeapNode.getKey() > newWeight) {
				oppositeHeapNode.getData().spanningTreeEdge = edge;
				heap.decreaseKey(oppositeHeapNode, newWeight);
			}
		}

	}

	@Override
	public ShortestPathTreeNode<V, E> getRootNode() {
		return RootNode;
	}
}